# Задание 4

## Вопрос

Вы запустили систему мониторинга и получаете тысячи алертов, при этом заметили, что на дашборде система мониторинга показывает, что SLA метрика `summ_2xx_requests/summ_all_requests` не поднимается выше 70%. Но при этом вы в курсе, что все запросы работают корректно, нет ошибочных кодов. В чем может быть проблема?

## Ответ

### Диагностика проблемы с SLA-метрикой (70% при отсутствии ошибок)

Если метрика `summ_2xx_requests/summ_all_requests` не превышает 70%, но при этом все запросы работают корректно и нет ошибочных кодов, проблема может быть в следующем:

#### 1. **Учёт редиректов (3xx коды)**

**Проблема:**
- HTTP коды 3xx (301, 302, 307, 308) - это редиректы, они считаются корректными ответами
- Но формула учитывает только 2xx коды

**Пример:**
```
Всего запросов: 1000
2xx ответов: 700 (70%)
3xx редиректов: 300 (30%)
4xx/5xx ошибок: 0

Текущая метрика: 700/1000 = 70%
Правильная метрика: (700+300)/1000 = 100%
```

**Решение:**
```
# Правильная формула для успешных запросов:
(summ_2xx_requests + summ_3xx_requests) / summ_all_requests

# Или для мониторинга только ошибок:
1 - (summ_4xx_requests + summ_5xx_requests) / summ_all_requests
```

#### 2. **Health Check запросы с неправильными кодами**

**Проблема:**
- Load Balancer или Kubernetes делают health check запросы
- Health check endpoint может возвращать 204 No Content или другие коды
- Если health check возвращает, например, 204, это тоже 2xx, но может быть проблема с парсингом

**Решение:**
- Проверить логи на наличие большого количества health check запросов
- Убедиться, что health check возвращают 200 OK
- Исключить health check из метрик SLA или учитывать их отдельно

#### 3. **Информационные запросы (1xx коды)**

**Проблема:**
- HTTP 100 Continue, 101 Switching Protocols
- Эти коды используются для WebSocket, HTTP/2 upgrade
- Они не являются ошибками, но и не 2xx

**Решение:**
```
# Учитывать 1xx как корректные ответы:
(summ_1xx_requests + summ_2xx_requests) / summ_all_requests
```

#### 4. **Неполный сбор метрик**

**Проблема:**
- Метрика `summ_all_requests` учитывает ВСЕ запросы
- Метрика `summ_2xx_requests` может не учитывать часть 2xx ответов
- Например, из-за фильтрации или неправильной агрегации

**Пример:**
```
# Неправильная агрегация
summ_all_requests = count(*)  # Считает ВСЕ
summ_2xx_requests = count(*) where status LIKE '2%'  # Может пропускать 200, 201, etc

# Правильная агрегация
summ_all_requests = count(*)
summ_2xx_requests = count(*) where status >= 200 AND status < 300
```

**Решение:**
- Проверить запросы к системе мониторинга
- Убедиться, что агрегация выполняется корректно
- Проверить временные интервалы агрегации

#### 5. **Requests без статус кода**

**Проблема:**
- Незавершённые запросы (connection timeout)
- Отменённые клиентом запросы
- Запросы, которые не достигли приложения
- Эти запросы могут учитываться в `summ_all_requests`, но не имеют статус кода

**Пример:**
```
Всего запросов: 1000
2xx ответов: 700
Запросы без статуса (timeout, cancel): 300

Метрика: 700/1000 = 70%
```

**Решение:**
- Проверить логи на наличие незавершённых запросов
- Исключить такие запросы из подсчёта `summ_all_requests`:
```
summ_all_requests = count(*) where status_code IS NOT NULL
```

#### 6. **Кеширование и CDN**

**Проблема:**
- CDN или reverse proxy может возвращать закешированные ответы
- Эти ответы могут не попадать в статистику приложения
- Но load balancer их учитывает

**Решение:**
- Проверить, откуда собираются метрики
- Убедиться, что метрики собираются на одном уровне (или LB, или приложение)
- Синхронизировать сбор метрик

#### 7. **Проблема с временными окнами агрегации**

**Проблема:**
- `summ_all_requests` и `summ_2xx_requests` могут агрегироваться в разных временных окнах
- Десинхронизация временных меток

**Пример:**
```
# summ_all_requests за 00:00-01:00 = 1000
# summ_2xx_requests за 00:05-01:05 = 700

# Метрика: 700/1000 = 70% (некорректно)
```

**Решение:**
- Убедиться, что обе метрики используют одинаковые временные окна
- Синхронизировать timestamps

#### 8. **OPTIONS preflight requests (CORS)**

**Проблема:**
- Для CORS браузер сначала отправляет OPTIONS preflight request
- Сервер может возвращать 204 No Content вместо 200 OK
- Или возвращать 403 Forbidden если CORS не настроен

**Решение:**
- Проверить количество OPTIONS запросов
- Убедиться, что они возвращают корректные статусы
- Рассмотреть возможность исключения OPTIONS из SLA метрик

### Практические шаги для диагностики:

```bash
# 1. Проверить распределение статус кодов
grep "HTTP/1.1" /var/log/nginx/access.log | cut -d'"' -f3 | cut -d' ' -f2 | sort | uniq -c | sort -rn

# 2. Посчитать процент каждого типа кодов
total=$(wc -l < access.log)
codes_2xx=$(grep " 2[0-9][0-9] " access.log | wc -l)
codes_3xx=$(grep " 3[0-9][0-9] " access.log | wc -l)
codes_4xx=$(grep " 4[0-9][0-9] " access.log | wc -l)
codes_5xx=$(grep " 5[0-9][0-9] " access.log | wc -l)

echo "Total: $total"
echo "2xx: $codes_2xx ($(echo "scale=2; $codes_2xx*100/$total" | bc)%)"
echo "3xx: $codes_3xx ($(echo "scale=2; $codes_3xx*100/$total" | bc)%)"
echo "4xx: $codes_4xx ($(echo "scale=2; $codes_4xx*100/$total" | bc)%)"
echo "5xx: $codes_5xx ($(echo "scale=2; $codes_5xx*100/$total" | bc)%)"

# 3. Проверить наличие запросов без статус кода
grep -v " [1-5][0-9][0-9] " access.log
```

### Рекомендуемое решение:

**Наиболее вероятная причина** - учёт 3xx редиректов.

**Исправленная формула:**
```
# Вариант 1: Учитывать 2xx и 3xx как успешные
success_rate = (summ_2xx_requests + summ_3xx_requests) / summ_all_requests

# Вариант 2: Отслеживать только реальные ошибки
error_rate = (summ_4xx_requests + summ_5xx_requests) / summ_all_requests
success_rate = 1 - error_rate

# Вариант 3: Исключить служебные запросы
success_rate = summ_2xx_requests / (summ_all_requests - health_checks - options_requests)
```

**Проверка гипотезы:**
```
# Если 70% + X% = ~100%, значит проблема в редиректах или других корректных кодах
# Посчитать сумму всех типов кодов и сравнить с общим количеством запросов
```
